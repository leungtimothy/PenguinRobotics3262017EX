#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    claw_pot_1,     sensorNone)
#pragma config(Sensor, in2,    arm_pot,        sensorPotentiometer)
#pragma config(Motor,  port1,           right_arm_1,   tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           claw_1,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           right_arm_2,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           left_arm_1,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           right_arm_3,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           claw_2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          left_arm_2,    tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
/* CLAW STATUSES */
#define CLAW_CLOSING 0
#define CLAW_OPENING 1
#define CLAW_SETPOINT 2

/* CLAW SETPOINTS */
#define CLAW_POS_CLOSE 1757
#define CLAW_POS_FUNNEL CLAW_POS_CLOSE+840
#define CLAW_POS_WIDE_OPEN CLAW_POS_CLOSE+1730

#define ARM_POS_BOTTOM 567
#define ARM_POS_OFF_GROUND ARM_POS_BOTTOM+250
#define ARM_POS_PUSH ARM_POS_BOTTOM+1300
#define ARM_POS_START_OPENING_CLAW_FOR_DUMP ARM_POS_BOTTOM+1750
#define ARM_POS_SCORE ARM_POS_BOTTOM+2450


#define NUM_OF_AUTOS 4

int autoMode = 0;
const string autoNames[] =
{
"Blue Auto 1",
"Blue Auto 2",
"Red Auto 1",
"Red Auto 2"
};

#define NUM_OF_DRIVER_LCD_PAGES 2
int driveLCDMode = 0;

#include "Penguin_LCD_Tasks.c"
#include "Penguin_Competition_Includes.c"
#include "Penguin_Motor_Functions.c"


int clawTaskEnable = 0;
int clawPosition = 0;

/* Claw Auto Open Stuff */
bool clawAutoOpen = false;
/* Claw Position to Open to*/
int clawAutoOpenPosition = 0;
/* Arm Position to Open at*/
int clawAutoOpenArmTriggerPos = 0;

int armTaskEnable = 0;
int armPosition = 0;

#include "Penguin_Claw_Arm_Tasks.c"
#include "Penguin_Auto_Functions.c"
#include "Penguin_Auto.c"


/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/


task autonomous()
{
	switch(autoMode)
	{
		case 0:
			blueAuto1();
			break;
		case 1:
			break;
		case 2:
			break;
		case 3:
			break;
		default:
			break;
	}
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
  // User control code here, inside the loop
	startTask(clawTask);
	startTask(armTask);

	bool clawMoving = false;
	int lastClawAction = 0;

	bool armMoving = false;

  while (true)
  {

  	/* */
  	if(vexRT[Btn8D])
 		{
 			clawTaskEnable = 1;
 			clawPosition = CLAW_POS_CLOSE;
  	}

  	if(vexRT[Btn8U])
  	{
  		clawTaskEnable = 1;
  		clawPosition = CLAW_POS_WIDE_OPEN;
  	}

  	if(vexRT[Btn8R])
  	{
  		clawTaskEnable = 1;
  		clawPosition = CLAW_POS_FUNNEL;
  	}

  	if(vexRT[Btn8L])
  	{
  		clawTaskEnable = 1;
  		clawPosition = SensorValue[claw_pot_1];
  	}

  	if(vexRT[Btn6U])
 		{
 			clawMoving = true;
 			clawTaskEnable = 0;
  		setClaw(127);
  		lastClawAction = CLAW_CLOSING;
  		writeDebugStreamLine("Closing Claw Button Held");
	 	}
	 	else if(vexRT[Btn6D])
	 	{
	 		clawMoving = true;
	 		clawTaskEnable = 0;
	 		setClaw(-127);
	 		lastClawAction = CLAW_OPENING;
	 		writeDebugStreamLine("Opening Claw Button Held");
		}
		else if(clawMoving == true && lastClawAction == CLAW_OPENING)
		{
			clawMoving = false;
			setClaw(0);
			clawPosition = SensorValue[claw_pot_1];
			clawTaskEnable = 1;
			writeDebugStreamLine("Holding Claw Position: %i", clawPosition);
		}
		else if(clawMoving == true && lastClawAction == CLAW_CLOSING)
		{
			clawMoving = false;
			setClaw(15);
			clawPosition = SensorValue[claw_pot_1];
			clawTaskEnable = 0;
			writeDebugStreamLine("Static Power Close at Claw Position: %i", clawPosition);
		}



		if(vexRT[Btn5U])
 		{
 			armMoving = true;
 			armTaskEnable = 0;
  		setArm(127);
  		writeDebugStreamLine("Arm Up Button Held");
	 	}
	 	else if(vexRT[Btn5D])
	 	{
	 		armMoving = true;
 			armTaskEnable = 0;
  		setArm(-127);
  		writeDebugStreamLine("Arm Down Button Held");
		}
		else if(armMoving == true)
		{
			armMoving = false;
			setArm(0);
			armPosition = SensorValue[arm_pot];
			armTaskEnable = 1;
			writeDebugStreamLine("Holding Arm Position: %i", armPosition);
		}

	}
}
